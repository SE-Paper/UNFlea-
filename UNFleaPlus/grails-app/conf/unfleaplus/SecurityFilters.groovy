package unfleaplus

/**
 * Generated by the Shiro plugin. This filters class protects all URLs
 * via access control by convention.
 */
class SecurityFilters {
    static nonAuthenticatedActions =[
		[controller:'index',action:'index' ],
		[controller:'index'],
		[controller:'index',action:'viewHome'],
		[controller:'index',action:'viewContactUs'],
		[controller:'index',action:'viewAboutUs'],
		[controller:'user',action:'viewRegister']		
	]
	static authenticatedActions=[
		[controller: 'user', action: 'viewHome', roles: ['ROLE_ADMIN', 'ROLE_USER']],
		[controller: 'user', roles: ['ROLE_ADMIN', 'ROLE_USER']],
		[controller: 'user',  action:'index',roles: ['ROLE_ADMIN', 'ROLE_USER']]
		
	]
	
	def filters = {
		
				all(controller: '*', action: '*') {
					before = {
		
						// Determine if the controller/action belongs is not to be authenticated
						def needsAuth = !nonAuthenticatedActions.find {
							(it.controller == controllerName) &&
									((it.action == '*') || (it.action == actionName))
						}
		
						if (needsAuth) {
		
							// Get the map within the authenticated actions which pertain to the current
							// controller and view.
							def authRoles = authenticatedActions.find {
								(it.controller == controllerName) &&
										((it.action == '*') || (it.action == actionName))
							}
		
							if (authRoles) {
		
								// Perform the access control for each of the roles provided in the authRoles
								accessControl {
									authRoles.roles.each { roleName ->
										role(roleName)
									}
								}
							}
		
							// Skip authentication if the authRoles was not found
							else {
								return true
							}
						}
		
						// Skip authentication if no auth is needed
						else {
							return true
						}
					}
				}
		
			}
}